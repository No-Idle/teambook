\subsection{$\mathcal{SCC}$ и 2-$\mathcal{SAT}$}
Алгоритм ищет сильносвязные компоненты в графе $g$, если есть путь $i \rightarrow j$, то $scc[i] \le scc[j]$

В случае 2-$\mathcal{SAT}$ рёбра $i \Rightarrow j$ и $(j\oplus1) \Rightarrow (i \oplus 1)$ должны быть добавлены одновременно.
\begin{lstlisting}
vector<vector<int>> g(2 * n);
vector<vector<int>> r(g.size());
for (int i = 0; i < g.size(); ++i) {
  for (int j : g[i]) r[j].push_back(i);
}
vector<int> used(g.size()), tout(g.size());
int time = 0;
auto dfs = [&](auto dfs, int cur) -> void {
  if (used[cur]) return;
  used[cur] = 1;
  for (int nxt : g[cur]) {
    dfs(dfs, nxt);
  }
  // used[cur] = 2;
  tout[cur] = time++;
};
for (int i = 0; i < g.size(); ++i) if (!used[i]) dfs(dfs, i);
vector<int> ind(g.size());
iota(ind.begin(), ind.end(), 0);
sort(all(ind), [&](int i, int j){return tout[i] > tout[j];});
vector<int> scc(g.size(), -1);
auto go = [&](auto go, int cur, int color) -> void {
  if (scc[cur] != -1) return;
  scc[cur] = color;
  for (int nxt : r[cur]) {
    go(go, nxt, color);
  }
};
int color = 0;
for (int i : ind) {
  if (scc[i] == -1) go(go, i, color++);
}
for (int i = 0; i < g.size() / 2; ++i) {
  if (scc[2 * i] == scc[2 * i + 1]) "IMPOSSIBLE"
  if (scc[2 * i] < scc[2 * i + 1]) {
    // !i => i, assign i = true
  } else {
    // i => !i, assign i = false
  }
}
\end{lstlisting}

%https://codeforces.com/contest/228/submission/230077013
%https://judge.yosupo.jp/submission/168750
%https://judge.yosupo.jp/submission/168753